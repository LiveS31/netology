 для создания проекта нужно:
django-admin startproject lesson1 .
django-admin - команда администратора
startproject - что делать (в двнном случае создать проект)
lesson1 - название проекта
. - где создать ( . - обознаечат в той же папке)

__Для запуска сервера  команда
python3 manage.py runserver
python3 manage.py- главный файл
runserver - что именно требуется запустить

если сервер запустился удачно будет вот такое сообщение:
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).

You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
Run 'python manage.py migrate' to apply them.
April 24, 2023 - 13:38:03
Django version 4.2, using settings 'lesson1.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.


КЛАССИЧЕСКИЙ СЕРВЕР И РОИТИНГ
для создания приложения нужно
python3 manage.py startapp demo
lдля запускаприложения:
python3 manage.py - обязательно
startapp - команда
demo - название приложения
demo - нужно обязательно добавть в файл settings -> install apps

в файле views - пишется функция (с обязательным значением request)
так же в данный файл импортируется библиотека HttpResponse (from django.http import HttpResponse)
в файле urls- происходит вызов функции (записанной в файле views)
(функцию требуется испортировать в файл urls. пример: from demo.views import index)
в файл urls - прописать вызов функции (path('', index), , где ''- указывается путь для вызова, index - сама функция)
для примера функция вывода времени
пишем в views
def time(request):
    return HttpResponse(f'Time = {datetime.datetime.now().time()}')
путь описываем в urls

дебаг проекта:
настройка запуска файла для запуска, появляется возвожность старта дебаг (режим отладки)

__параметрализация запроса:
чтобы сосдать запрос ?name=Sasha
? - то что будет отправлен запрост на сервер
name - параметр (name для примера)
sasha - значением (sasha для примера)
далее дополнительные парамеры чрез &
&age=22 - пример

чтобы передавать параметры в url через функцию:
sum/<a>/<b>/ - где a and b есть переменные для передачи
параметры <a>/<b> должны называться обязательно одинаково с названием в функцыи

введение в шаблоны:
шаблоны это расширенный HTML запрос
настройки располагаются в файле settings -> TEMPLATES
DIRS': [] - папки приложений
'APP_DIRS': True - искать шаблоны в папках приложений
нужно создать папку TEMPLATES в папке приложения
в папке TEMPLATES создаем шаблон HTML ( например demo.html)
можно передавать параметры в словаре
создаем context - это простой словарь
{%for x in data %} - списки можно перебирать циклом
    {{ x }}
    {% endfor %} - но его нужно закрыть

чтобы список был маркированный
<ul style="color: orange; font-size:50px">
    {%for x in data %}
    <li>{{ x }}</li>
    {% endfor %}
</ul>
так же можно примемять условия
{% if x > 5%}
{% endif %} - нужно обязательно закрывать
можно применять такие усвия как upper - тоже будеттработать как в python

пагинация
{% for e in page %}
<p>{{ e }}</p>
{% endfor %}
делаем кнопки вперед, назад в pagi
{% if page.has_previous %}
<a href="?page={{ page.previous_page_number}}">Назад</a>
{% endif %}

{% if page.has_next %}
<a href="?page={{ page.next_page_number}}">Вперед</a>
{% endif %}

__________________________

ORM/BASE DATA
orm - прозрачность работы с базами данных
информация храмнится в файле models.py
для примера
в файле models.py
создаем КЛАСС
class Car(models.Mode):
    brand = models.CharField(max_length =50)
    model = models.CharField(max_length =50)
    color = models.CharField(max_length =20)
где brand, model, color - название колонок таблици, а
models.CharField(max_length =50) - текстовая колонка с длинной в 50 символов
+ django добовляет еще один столбик - id. итого в таблице Сar получается 4 столбика

Создаем еще одну таблицу
class Person(models.Model):
    name = models.CharField(max_length= 50)
    car = models.ForeignKey(Car, on_delete=models.CASCADE)
models.ForeignKey(Car, on_delete=models.CASCADE)- значит связать с таблицей (классом) CharField
при этом CAR - с какой таблицей связать,
on_delete=models.CASCADE- что сделать если такой записи нет.

для того чтобы работала такая функция -
заегистрировать приложение ( это стандартно)
+ в терминале прописать python manage.py makemigrations
(после этого появится еще один файл в папке миграция
после выполнениея команды нужно приминить миграцию командой:  python manage.py migrate
после этого так же создается и база данных
настройки ее можено посмотреть в файле settings.py DATABASES

чтобы подключить (изменить базу данныйх нужно)
1. создать базу данных (createtdb -U postgres demoorm)
2. установить драйвер (pip install psycopg2-binary)
3. В settings изменить на базу данных postgressql
   NAME: 'demoorm'
   USER: 'postgres'
   PASSWORD: 'postgres'
4. повторить миграцию   python manage.py migrate

Заметки в базу данных:
открываем файл views.py
создаем функцию:
def create_car(request):
    car = Car(brand='demo', model='demo', color='demo')
где заполняем таблицу
    car.save()
- запись данных в таблице
    return HttpResponse(f'Все получилось {car.brand}, {car.model}')

для вызова, как обычно прописывем путь  в urls.py
pach('new_car/', create_car)

далее создадим несколько авто:
import random

def create_car(request):
    car = Car(
    brand=random.choice(['B1', 'B2', 'B3']),
    model=random.choice(['M1','M2','M3']),
    color=random.choice(['C1','C2','C3'])
    )
где заполняем таблицу
    car.save()
- запись данных в таблице
    return HttpResponse(f'Все получилось {car.brand}, {car.model}')

для вывода объекта
def list_car(request):
    car.objects = Car.objects.all()
- где objects- это менеджер по управлению,
- all - все данные в таблице
- Сar - класс (или в данном месте таблица ) из колторой нужно выбирать данные.
    cars = [f'{c.brand, {c.model}: {c.color}' for c in car_objects]
- получаем строку из таблицы Car циклом с переменной с.
--если нужно получить столбик ID - дописать cars = [f'{c.id}, {c.brand, {c.model}: {c.color}' for c in car_objects]
    return HttpResponse('<br>'.json(cars))
- выводим данные в из таблици
<br> - каждый вывод с новой строки

далее так же добавляем в файле views.py pach('cars/', list_car)
(не забываем импортировать)

чтобы выролнить выборку по нужному фильтру нужно:
def list_car(request):
    car.objects = Car.objects.filtet(brand='B1) - будет выбраны все таблицы где присутствует B1
-- если (brand__contains='2') - все бренды содержащие '2'
-- если (brand__startswith='2') - все бренды, что начинаются со строки '2'
    cars = [f'{c.brand, {c.model}: {c.color}' for c in car_objects]
    return HttpResponse('<br>'.json(cars))

присвоим каждому человеку свой автомобиль:
def create_person(request):
    cars = Car.objects.all()
    for car in cars:
        Person(name='P', car=car).save()
-Person(name='P', car=car).save()- записываем данные имя =Р, car - соответствует циклу, save- соответствует циклу For
- или можно еще так:
        Person.objects.create(name='P', car=car)
    return HttpResponse('Все получилось'))
создаем новый маршрут в path('new_person/', create_person),

--для вывода из таблици сделаем функцию как и с кар
def list_person(request):
    person_objects = Person.objects.all()
    people = [f'{p.name}:{p.car} for p in person_objects]
    return HttpResponse('<br>'.json(pejple))
регистрируем:
path('people/', list_person)

чтобы получить владельца наоборот нужно дописать в models.py

retated_name='owners'  - описывает связь в обратную сторону

class Person(models.Model):
    name = models.CharField(max_length= 50)
    car = models.ForeignKey(Car, on_delete=models.CASCADE, retated_name='owners')
models.ForeignKey(Car, on_delete=models.CASCADE)- значит связать с таблицей (классом) CharField
при этом CAR - с какой таблицей связать,
on_delete=models.CASCADE- что сделать если такой записи нет.

-доавим информацию для выборки данных по обратной связи:

{c.oweners.count()} - по обратной связи в таблице, счетчики.. (можно применить и другие фильтра)

def list_car(request):
    car.objects = Car.objects.filtet(brand='B1)
    cars = [f'{c.brand, {c.model}: {c.color}|{c.oweners.count()}' for c in car_objects]
    return HttpResponse('<br>'.json(cars))

___создание административной панели по управлению базой данных

в файле admin.py
(в него же импортирм from .models import Person, Car)
с помощью декоратора @
@admin.register(Car) - будет администратором для модели Car

class CarAdmin(admin.ModelAdmin):
    pass

Если перейти в браузере /admin/ - откроется меню введите логин и пароль.
чтобы создать поьзователя нужно в окне терминала:
python3 manage.py createsuperuser
ввести пользователя:
ввести почту: - можно оставить пустым
ввести пароль: - с повторением

--после этого можно войти в административную панель dgango
набрав в браузере /admin/

войдя попадаем в меню секций
1. пользовате и аутификация и пользователи (их не трогаем - из коробки)

2. называется так же как и приложение. в данном приложении нахродится наша модель (Car)

--настраиваем отображение в административной панеле
class CarAdmin(admin.ModelAdmin):
    list_display = ['id', 'brand', 'model', 'color',]
где list_display- list обображеня. далее столбцы для отображения]
    list_filter = ['brand','model']
где list_filter- параметр, далее значение параметра

и парамер Person

@admin.register(Person)
class PersonAdmin(admin.ModelAdmin):
    list_display = ['is', 'name', 'car']

--ORM2--

базы данных то модели и после изменению нужно делать миграцию

1. Создание связей многие ко многим:
в модуле models.py

создаем таблицу модели
class Product(models.Model):
    name = models.CharField(max_length=100) # текстовая столбец с именем name и ограничением в 100 символов
    price = models.IntegerField() # столбец price - цыфра без ограничения по цифрам
    category = models.CharField(max_length=50)

вторая таблица заказ:

class  Order(models.Model):
    products = models.ManyToManyField(Product, related_name='orders')
ManyToManyField - связь многие ко многим
Product - таблица к которой обращаемся
related_name= - чтобыиз другой таблице тоже можно было обратиться к заказу
'orders' - название  ( и те заказы в которых учавствует продукт)
теперь можно получить все заказы через product и из заказов через orders

создаем миграцию через python3 manage.py mikemigrations - создаем таблицу и миграцию
для создания страниц
применени'orders'не миграции python3 manage.py migrate - применяем миграцию

для вывода заказа нужно колличества товара нужно промежуточная модель(таблица)
(django - создаст ее автоматически, но можно создать сомостоятельно)
для этого:

class OrderPosition(models.Model):
    product = models.ForeignKey(Product, on_delete=CASCADE, related_name='positions')
on_delete=CASCADE - удаление использует каскад при отсутствии данных
related_name='position' получаем позиции от продукта в которых он учавствует
ForeignKey - внешний ключ
    order = model.ForeignKey(Order, on_delete=models.CASCADE, related_name='positions')
    order - тот заказ к которому относится эта позиция
    related_name='positions' - чобы из заказа тоже можно было достуаться до позиции.
    quantity = moduls.IntegerField() - это будет счетчик и целое число,  которое будем испольоват

После эих действий нужно выполнить миграцию и применить ее.
Будет создан файл 0002_.......py - в папке migrations.

==Настройка панели администратора

переходим в admin.py
пропишем класс для продуктов

from .moduls import Product, Order, OrderPosition - импортируем классы

@admin.register(Product)
class ProductAdmin(admin.ModulAdmin):
Настроим отображение
    list_display = ['id', 'name', 'category', 'price']
настроем фильтр
    list_filter = ['category']


регистрируем таблицу Order

@admin.register(Order)
class OrderAdmin(admin.ModulAdmin):
    list_display = ['id']


нам нужны инлайн модели позволяет встраивать в наше отображерние другое отображение
создаем inline модель

class OrderPositionInLine(admin.TabularInLine):
необходимо указать модель (обязательный параметр)
    model = OrderPosition
и есть необязательные параметры например
    extra = 3 (это значение по умолчанию, отвечает за количестро строк)

теперь дописываем таблицу OrderAdmin
@admin.register(Order)
class OrderAdmin(admin.ModulAdmin):
    list_display = ['id']
    inlines = [OrderPositionInLine] - говорим, что будем использовать эту позицию

-- Убираем дублирование
переходим в models
в таблице
class Order(models.Model):
    заменяем записи на
    pass

Вся связь бдет производиться с помощью талицы OrderPosition
и сново выполнить миграции.

    ===как делать  все в коде
переходим в views.py
получать данные будеим через шаблон
def list_ordres(request):
    orders = Order.objects.all() - получаем все заказы
передаем их всех в контекст
    context = {'orders':order} -   в наш список заказов
    return render(request, 'orders.html', context)

== для работы шаблонов создаем папку TEMPLATES
    внутри создаем файл orders.HTML

в TEMPLATES order.html пишем
{% for order in orders %}
    <p>Заказ №{{ order.id }}</p>
пройдемся циклопо всему
{% for possition in order.possition.all %} - .possition.all - я вляется менеджером и all можно заменить на filtet и вывасти только нужные данные
например {% for possition in order.possition.filter(positions__product__price__gte=600 %}
gte - больше, lte- меньше,.....
<p>{{ position.product.name }}:{{ position.quantity }}</p>
{% endfor %}
{% endfor %}

pзаходим в urls.py
прописываем путь
path ('orders/', list_ordres),

through -параметр можно явно указать промежуточную таблицу для связи «многие ко многим»

modesl- разобраться

-- Для использования окружеия (спрятать код)используют слдующее окружение:
    python-dotenv
    python-decouple
    django-environ
pip install - имя пакета
после заводим специальный файл .env
для забора данных из файла -
import os
from dotrnv import load_dotenv
load_dotenv()
SECRET KEY = os.getenv('SECRET')
где SECRET KEY - это значение в settings.py
    SECRET - это код из файла который мы импортируем
    load_dotenv - это функция с помощью чего прооисходи вызов
для ALLOWED_HOST - os.getenv('ALLOWED_HOST).split(',')

slug - это строка которая может содержать буквы, цифры, нужние подчеркивания, дефис
НЕ МОЖЕТ содержать специальные символы
применяется в интернет магазинах - тренслитированное название товара (новости) + какой то рандомный id
напоминание:
unique=True - уникальное значение
on_delete = models.CASCADE - удаление при отсутствие
related_name - какое то название по которо можно получить связанные объекты
models.DecimalField(max_digits=10, decimal_places=2) - для цены лучше использовать его
у него два параметра max_digits - максмальное значение цыфр ,
decimal_places - колличество знако после запятой
метод str  - для того , чтобы нормально чтобы нормально выводилась иформаця из таблица
в противном случае будет выводить ячейку папяти
blank=True- поле может быть пустым (не обязательно для ввода)
ManyToManyField - связь многие ко многим
DateTimeField - заполнение декоратора
DateTimeField(auto_now_add=True) - заполнение автоматически
SmollIntengerFild - скольно можно заказать ( сколько он может хранить(\
(максимум 32000)
PositiveSmollIntengerFild- может хранть только положительные значения
class Meta - класс в котором содержится дополнительная информация
(например сортировк, индексы...)
_- когда создаем классы в models -> создаются таблицы.
но все имена таблиц начинаются с main_....
чтобы таблицы назывались, как нужно без дополнительных надписей ->  в классе Meta
нужно написать (пример):
    class Meta:
        db_tadle = 'название таблици' - писать в классе создания таблиц

__обращение к базе данных (для примера)
class ProductListView(View):
    def get(sefl,  request):
        product = Product.objects.all()
        return render(request, templaete_name, {'product': product})
Product - это база данных
objects - обращение в базу данных
.all - обращение в базу данных

-- файлы urls.py можно создавать в каждом тепплайте
для жто создаем файл и внутри обязательно пишем
from django.urls inmport path
urlpatterns = [
тут пишем пути типа
path = ('product/', ProductListView.as_view(), name='list']
-- в файле views.py
в классе что открыт на странице:
paginate_by - выбираем колличество отображения на странице
page_kwarg = 'p' - ключ для вывода отображения запроса
выглядит в браузере так - padge=2 (где 2 нмер страниц)
__фильтрация:
создаем класс и наследуем его от родительского (Для примера)
def get_quryset(self):
    queryset = super().get_quryset() - получаем данные от родительского класса
    price_from = self.request.GET.get('price_from', 0) - получаем параметры от (0 поумолчанию)
    price_to = self.request.GET.get('price_to', 0) - до 0 получаем параметры до (0 поумолчанию)
    if price_from:
        queryset = queryset.filter(price__gte=price_from)
    if price_to:
        queryset = queryset.filter(price__lte=price_to)
--get, lte - это условия к действию
     q = self.request.GET.Get('search')
        if q:
            queryset = queryset.filter(name__incontains=q)
    return queryset - возвращаем его
--Обязательные параметры

class ProductsListByCategory(view):
    def get(sefl, request, обязательный параметр category_id):
        product = Product.objects.filter(category_id=category_id) - фильтрация
        (в самой таблице отображается как category_id - не смотря та то , что пишем как category)
        templaete_name = 'product/list.html'
        return render (request, templaete_name, {'product': product}))
 обязательный параметр нужно добавит в urls
 path('products/<slug:category_id>/', ProductsListByCategory.as_view(), name= 'list-by-category')

 ---
 Знакомство с API на примере Django REST framework
 ---
 1.Устанавливаем библиотеку фраемворка
    pip install djangorestramework
 2. добовляем его в setting.py -> installed_apps -> add "rest_framework'

 Сама работа с обработчиками
 (view)
 @api_view(['GET']) #декоратор из библиотеки
def game(request):
    data = {'message':'Hello'} #словарь сообщение и текст сообения
    return Response(data) # Response - обработчик импортируем
    (urls)
paht('demo/', game)
сделать миграцию

---теперь работа с моделями
создадит класс оружия

class Wearpon(models.Model):
    power = models.IntegerField()
    rerety = models.CharField(max_length=50)
    value = models.IntegerField()
Wearpon(power = 10, rerety='apple', value = 100).save() - добовляем в него
-
саризатор (serializers.py)- специальных класс которы знает как превравтить сложный файл в объект
json
(он создается вручную в приложении, где миграция)

открываем Visual Studio Code , устанавливаем рест клиент, создаем файл .http
и пишим в них запросы
GET http://locaalhost:8000/demo/
(запросы отделяются ### в начале строки)
#    path('demo/', GameView.as_view()), - нужно зарегистрировать
# и импоритировать данный класс

class GameView(APIView): # наследуется от APIView - нужно импортироать
    def get(self, requst): #метод get, который примнимает request
        weapons = Wearpon.objects.all()
        ser = WeaponSerializer(weapons, many=True)
        return Response(ser.data)
    def post(self, request): # метод post
        return Response({'status': 'Ok'})

---узнать индификатор оружия , который поместили в таблицу
# для отображения оружия
class WeaponView(RetrieveAPIView): # наследем и нужно его импортировать
    queryset = Wearpon.objects.all()  # для него требуется указать откуда
    serializer_class = WeaponSerializer #Через что отображать
в urls прописать
path('weapon/<pk>/', WeaponView.as_view()),
]
# где pk = ключ

для того чтобы получать номер оружия нужно в setializator добавить поле id
fields = ['id', 'power', 'rerety'] # список свойств для отображения
        #добавили поле id для получения информации о номере оружия

